# Dispatch 调度

## 简介

传统的MVC设计模式中，`C`(Controller)负责响应路由请求并从所需的`M`(Model)中获取数据接着由`V`(View)渲染所需的视图文件，
每个层级各司其职，这是一种很好的设计模式，能够使各层级职能分配清楚，极大的解耦各层级的关联性而又不损害其所需的相关性。

然而，在`WoCenter`实际开发的过程中，在应对真正多主题或高个性化定制的情况下，传统设计模式并不能很好地满足需求，
故在传统设计模式中的`C`和`V`之间新增一个调度层(**Dispatch**，简称`D`)，用以进一步解藕细分`C`，同时为二次开发提供更高的友好性和适用性。

## 位于哪里

当`C`获取到请求路由时，系统会自动响应当前请求操作所属的`D`，然后通过`D`调度资源（从`M`中获取数据），
接着由`V`渲染所需的视图文件。线性关系如下：

传统模式：
`C` --> `M` --> `V`

WoCenter:
`C` --> `D` --> `M` --> `V`

## 如何使用

- 如果是全新开发的模块或功能，通过**`WoCenter Gii`**代码生成器即可方便生成所需代码，完全开箱即用。

- 如果是手动更改原有的`C`来使用调度功能，按照以下步骤操作即可：
    1. 待修改的`C`添加`WoCenter`调度功能的trait，`use wocenter\traits\DispatchTrait`或继承`wocenter\core\Controller`类
    2. 把需要调度功能的操作方法`actionXyz()`里面的代码转移到该操作专属的`D`（如：`Xyz`），把`$this`修改为`$this->controller`，
    然后删除`actionXyz()`方法，接着添加`dispatches()`方法返回需要使用调度功能的操作ID（如：`xyz`）数组即可。

        具体实现可参考系统核心模块的`C`和`D`，如：

        `C`: `wocenter\backend\modules\log\controllers\ActionController::actionIndex()`

        `D`: `wocenter\backend\themes\adminlte\dispatches\log\action\Index`

## 是否冲突

`WoCenter`在设计之初就非常重视开发者对于二次开发的需求和便捷性，所以系统所有的功能、模块、组件都在很大程度上可以被重构或替代，
并保持Yii2原有的设计理念和使用习惯，让开发者在使用新功能的同时不需要额外增加太多的学习成本。

**在平衡各方利弊后构建出`WoCenter`所特有的功能和服务都是非常容易进行二次开发，尤其是系统在响应请求路由时所做出的调度反馈。**

`D`的存在，把原有`C`的操作方法分为更小的粒度，在这基础上，每一个二次开发都是非常简单，同时对于多主题的支持也是无缝衔接，
这得益于`D`的良好设计。在提供新功能的同时并不对原有系统造成太多影响。

**在使用`D`的过程中遵循以下优先级规则：**

1. `C`存在`actions()`方法时，执行该操作。（Yii2原有的功能支持和优先级）
2. `C`存在`actionXyz()`方法时，执行该操作。（Yii2原有的功能支持和优先级）
3. `C`存在`dispatches()`方法时，执行该操作。（`WoCenter`的调度功能支持）

很明显，`D`在提供调度功能支持的同时保留着对Yii2原有的功能支持，正因为如此，使用`D`并不会和开发者原有的操作有任何的冲突。

## 何时使用

1. 需要高可定制的操作方法，如系统内所有的核心操作，使用调度可以很方便地被重构。
2. 采用多主题模式并且各个或个别主题需要自定义返回不同格式的结果数据、页面数据等主题相关性强的情况下使用。

    在很多时候，操作返回的数据格式、需要调度的页面数据都和不同主题有较强的相关性（区别于一般的主题样式改变，而是页面功能和架构上
    的改变）。

    如主题A列表页面同时显示搜索表单提供数据筛查功能，而主题B的搜索表单则是通过AJAX等方式动态显示，显然B主题需要调度的页面资源数据
    和A主题不一样，此时如果采用同一个`actionXyz()`方法提供页面数据或返回特定格式的结果数据的做法显然不能适用所有主题的个性化要求
    与设计，同时也可能给不同主题的页面提供不相关的资源数据，因此为每套主题提供专属的`D`显得很有必要。

    并且有时面对`C`复杂的操作设计，会导致`C`方法量或单个操作代码过多，这与瘦控制器胖模型的设计背道而驰，而`D`则可以有效地把复杂
    的设计解藕分离出来，针对单个操作提供专属的`D`，实现一对一的关系，方便管理和部分代码重用，同时也能起到瘦控制器的作用，并可使
    控制器与主题相关性不强，满足系统较高的可定制化需求。

## 配置说明

`Controller::dispatches()`支持以下配置数组：

```
public function dispatches()
{
    return [
        'update', // 直接指定需要调度的操作id
        'update' => 'edit', // 直接使用调度器映射，将调用'Edit'调度器替代原来的'Update'调度器
        'update' => [
            // 使用该类创建调度器，该类必须继承`wocenter\core\Dispatch`。注意：当该值被指定，`dispatchOptions`配置将不生效
            'class' => 'namespace/dispatches/Edit',
            'attribute' => 'value', // 支持对调度器类属性的配置
        ],
        'update' => [
            'dispatchOptions' => [
                // 是否调用指定主题的调度器，系统会调用该主题下指定路由的调度器。当该值为`false`时，将禁用控制器[Controller::$dispatchTheme]]配置
                'theme' => 'basic',
                // 是否自定义开发者主题基础路径，系统会调用该路径下指定路由的调度器，使用别名路径，默认为'@app/themes'，即为
                // 当前应用的themes主题目录。详情请看：[[\wocenter\core\View\getBaseThemePath()]]
                // 系统调度器目录默认位于主题目录下的dispatches文件夹，此处只需指定到主题目录themes路径即可
                'themePath' => '@common/themes',
                'map' => 'edit', // 使用调度器配置映射，将调用'Edit'调度器替代原来的'Update'调度器
            ],
        ],
    ];
}
```

> 注意：配置映射后，如果调度器内使用的是[[display()]]方法进行页面渲染而没有指定方法内的`$view`参数，
则该方法将自动用所调用的调度器ID所对应的视图文件进行渲染。如：[[Update]]用[[Edit]]进行映射后所对应的是`update`视图文件而不是映射后的`edit`），
如果需要用[[Edit]]调度器所对应的视图文件（如：`edit`）进行渲染，则只需要显式配置`$view`参数即可，
如：[[display(edit)]]
